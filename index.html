<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Person Follower</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
            background: #000;
            display: block;
            visibility: visible;
        }
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            z-index: 100;
        }
        #controls input { 
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
            margin: 5px 0;
            width: 200px;
        }
        #controls button {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: monospace;
            font-weight: bold;
        }
        #controls button:hover { background: #0f0; color: #000; }
        #controls button.active { background: #f00; color: #fff; border-color: #f00; }
        #controls button:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            border-color: #444; 
            color: #444; 
        }
        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #0f0;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            min-width: 300px;
            z-index: 100;
        }
        .status-row { 
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 14px;
        }
        .status-label { color: #888; }
        .status-value { color: #0f0; font-weight: bold; }
        .status-value.warn { color: #ff0; }
        .status-value.error { color: #f00; }
        #telemetry {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            max-height: 150px;
            overflow-y: auto;
            width: 400px;
            z-index: 100;
            font-size: 12px;
        }
        .log { margin: 2px 0; }
        .log.info { color: #0ff; }
        .log.warn { color: #ff0; }
        .log.error { color: #f00; }
        .log.success { color: #0f0; }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <div><input type="text" id="espIP" placeholder="ESP32 IP (192.168.x.x)"></div>
            <div>
                <button id="startBtn" onclick="startSystem()">START</button>
                <button id="followBtn" onclick="toggleFollow()" style="border-color: #888; color: #888">FOLLOW OFF</button>
                <button onclick="emergencyStop()" style="border-color: #f00; color: #f00">STOP</button>
            </div>
            <div style="margin-top: 10px; font-size: 11px;">
                <div>PID Tuning:</div>
                <div>Steer Kp: <input type="number" id="steerKp" value="2.5" step="0.1" min="0" max="100" style="width: 80px"></div>
                <div>Steer Kd: <input type="number" id="steerKd" value="1.2" step="0.1" min="0" max="100" style="width: 80px"></div>
                <div>Speed Kp: <input type="number" id="speedKp" value="200" step="10" min="0" max="1000" style="width: 80px"></div>
            </div>
        </div>
        
        <div id="status">
            <div class="status-row"><span class="status-label">State:</span><span class="status-value" id="stateDisplay">INIT</span></div>
            <div class="status-row"><span class="status-label">ESP32:</span><span class="status-value" id="connectionStatus">DISCONNECTED</span></div>
            <div class="status-row"><span class="status-label">Target X:</span><span class="status-value" id="targetX">-</span></div>
            <div class="status-row"><span class="status-label">Target Size:</span><span class="status-value" id="targetSize">-</span></div>
            <div class="status-row"><span class="status-label">Error X:</span><span class="status-value" id="errorX">-</span></div>
            <div class="status-row"><span class="status-label">Error Size:</span><span class="status-value" id="errorSize">-</span></div>
            <div class="status-row"><span class="status-label">Steer:</span><span class="status-value" id="steerOut">0</span></div>
            <div class="status-row"><span class="status-label">Drive:</span><span class="status-value" id="driveOut">0</span></div>
            <div class="status-row"><span class="status-label">FPS:</span><span class="status-value" id="fps">0</span></div>
            <div class="status-row"><span class="status-label">Confidence:</span><span class="status-value" id="confidence">-</span></div>
        </div>
        
        <div id="telemetry"></div>
    </div>

    <script>
        // ============ CONFIGURATION ============
        const CONFIG = {
            // Target distance (person size as % of screen)
            TARGET_SIZE: 0.20,           // Ideal person size (20% of screen)
            MIN_SIZE: 0.08,              // Too far
            MAX_SIZE: 0.35,              // Too close
            
            // Dead zones
            CENTER_DEADZONE: 0.08,       // Â±8% from center = no steering
            SIZE_DEADZONE: 0.03,         // Â±3% from target size = no speed change
            
            // Speed limits
            MAX_DRIVE: 60,               // Max forward speed
            MAX_STEER: 100,              // Max steering angle
            MIN_DRIVE: 25,               // Minimum speed to move
            
            // Control rates
            DETECTION_RATE: 100,         // 10 Hz detection
            COMMAND_RATE: 100,           // 10 Hz commands to ESP32
            
            // Tracking
            LOST_TIMEOUT: 15,            // Frames before declaring person lost
            MIN_CONFIDENCE: 0.5,         // Minimum detection confidence
            
            // Smoothing
            KALMAN_PROCESS_NOISE: 0.01,
            KALMAN_MEASUREMENT_NOISE: 0.5,
        };

        // ============ GLOBAL STATE ============
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let model = null;
        let systemRunning = false;
        let followActive = false;
        let espIP = '';
        
        // PID Controllers
        let steerPID, speedPID;
        
        // Kalman Filters
        let xFilter, sizeFilter;
        
        // Tracking state
        let targetPerson = null;
        let lostFrames = 0;
        let lastCommandTime = 0;
        let frameCount = 0;
        let lastFPSTime = Date.now();
        
        // Performance
        let detectionTimes = [];

        // ============ PID CONTROLLER CLASS ============
        class PIDController {
            constructor(kp, ki, kd, outputMin, outputMax) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
                this.outputMin = outputMin;
                this.outputMax = outputMax;
                
                this.lastError = 0;
                this.integral = 0;
                this.lastTime = Date.now();
            }
            
            update(error) {
                const now = Date.now();
                const dt = (now - this.lastTime) / 1000; // Convert to seconds
                
                if (dt <= 0) return 0;
                
                // Proportional
                const P = this.kp * error;
                
                // Integral with anti-windup
                this.integral += error * dt;
                const maxIntegral = this.outputMax / (this.ki || 1);
                this.integral = Math.max(-maxIntegral, Math.min(maxIntegral, this.integral));
                const I = this.ki * this.integral;
                
                // Derivative
                const derivative = (error - this.lastError) / dt;
                const D = this.kd * derivative;
                
                // Calculate output
                let output = P + I + D;
                
                // Clamp output
                output = Math.max(this.outputMin, Math.min(this.outputMax, output));
                
                // Update state
                this.lastError = error;
                this.lastTime = now;
                
                return output;
            }
            
            reset() {
                this.lastError = 0;
                this.integral = 0;
                this.lastTime = Date.now();
            }
            
            setGains(kp, ki, kd) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
            }
        }

        // ============ KALMAN FILTER CLASS ============
        class KalmanFilter1D {
            constructor(processNoise, measurementNoise) {
                this.q = processNoise;      // Process noise
                this.r = measurementNoise;  // Measurement noise
                this.x = 0;                 // Estimated value
                this.p = 1;                 // Estimation error covariance
                this.k = 0;                 // Kalman gain
            }
            
            update(measurement) {
                // Prediction
                // x = x (no change in prediction)
                this.p = this.p + this.q;
                
                // Update
                this.k = this.p / (this.p + this.r);
                this.x = this.x + this.k * (measurement - this.x);
                this.p = (1 - this.k) * this.p;
                
                return this.x;
            }
            
            reset(value = 0) {
                this.x = value;
                this.p = 1;
            }
        }

        // ============ PERSON TRACKER CLASS ============
        class PersonTracker {
            constructor() {
                this.trackedBBox = null;
                this.lostCount = 0;
                this.trackingHistory = [];
                this.maxHistory = 5;
            }
            
            calculateIOU(box1, box2) {
                const x1 = Math.max(box1[0], box2[0]);
                const y1 = Math.max(box1[1], box2[1]);
                const x2 = Math.min(box1[0] + box1[2], box2[0] + box2[2]);
                const y2 = Math.min(box1[1] + box1[3], box2[1] + box2[3]);
                
                if (x2 < x1 || y2 < y1) return 0;
                
                const intersection = (x2 - x1) * (y2 - y1);
                const union = box1[2] * box1[3] + box2[2] * box2[3] - intersection;
                
                return intersection / union;
            }
            
            update(people) {
                if (people.length === 0) {
                    this.lostCount++;
                    if (this.lostCount > CONFIG.LOST_TIMEOUT) {
                        this.trackedBBox = null;
                    }
                    return this.trackedBBox;
                }
                
                // First detection - pick largest person
                if (!this.trackedBBox) {
                    const largest = people.reduce((max, p) => 
                        (p.bbox[2] * p.bbox[3] > max.bbox[2] * max.bbox[3]) ? p : max
                    );
                    this.trackedBBox = largest.bbox;
                    this.lostCount = 0;
                    return this.trackedBBox;
                }
                
                // Track using IOU
                let bestMatch = null;
                let bestIOU = 0.2; // Minimum IOU threshold
                
                for (const person of people) {
                    const iou = this.calculateIOU(this.trackedBBox, person.bbox);
                    if (iou > bestIOU) {
                        bestIOU = iou;
                        bestMatch = person;
                    }
                }
                
                if (bestMatch) {
                    this.trackedBBox = bestMatch.bbox;
                    this.lostCount = 0;
                } else {
                    this.lostCount++;
                    if (this.lostCount > CONFIG.LOST_TIMEOUT) {
                        this.trackedBBox = null;
                    }
                }
                
                return this.trackedBBox;
            }
            
            reset() {
                this.trackedBBox = null;
                this.lostCount = 0;
                this.trackingHistory = [];
            }
        }

        // ============ DECISION ENGINE ============
        class FollowingStateMachine {
            constructor() {
                this.state = 'SEARCHING';
                // States: SEARCHING, APPROACHING, FOLLOWING, TOO_CLOSE, LOST
            }
            
            updateState(hasTarget, personSize) {
                if (!hasTarget) {
                    if (this.state !== 'LOST' && this.state !== 'SEARCHING') {
                        this.state = 'LOST';
                    } else if (lostFrames > CONFIG.LOST_TIMEOUT) {
                        this.state = 'SEARCHING';
                    }
                } else {
                    if (personSize < CONFIG.MIN_SIZE) {
                        this.state = 'APPROACHING';
                    } else if (personSize > CONFIG.MAX_SIZE) {
                        this.state = 'TOO_CLOSE';
                    } else {
                        this.state = 'FOLLOWING';
                    }
                }
                
                return this.state;
            }
        }

        // ============ INITIALIZATION ============
        const personTracker = new PersonTracker();
        const stateMachine = new FollowingStateMachine();

        function validatePIDValue(value, min, max, defaultValue) {
            const num = parseFloat(value);
            if (isNaN(num) || num < min || num > max) {
                return defaultValue;
            }
            return num;
        }
        
        function initControllers() {
            const steerKp = validatePIDValue(document.getElementById('steerKp').value, 0, 100, 2.5);
            const steerKd = validatePIDValue(document.getElementById('steerKd').value, 0, 100, 1.2);
            const speedKp = validatePIDValue(document.getElementById('speedKp').value, 0, 1000, 200);
            
            // Update UI with validated values
            document.getElementById('steerKp').value = steerKp;
            document.getElementById('steerKd').value = steerKd;
            document.getElementById('speedKp').value = speedKp;
            
            steerPID = new PIDController(steerKp, 0, steerKd, -CONFIG.MAX_STEER, CONFIG.MAX_STEER);
            speedPID = new PIDController(speedKp, 0, 10, -CONFIG.MAX_DRIVE, CONFIG.MAX_DRIVE);
            
            xFilter = new KalmanFilter1D(CONFIG.KALMAN_PROCESS_NOISE, CONFIG.KALMAN_MEASUREMENT_NOISE);
            sizeFilter = new KalmanFilter1D(CONFIG.KALMAN_PROCESS_NOISE, CONFIG.KALMAN_MEASUREMENT_NOISE * 2);
        }

        // ============ INITIALIZATION - SIMPLIFIED LIKE REFERENCE CODE ============
        async function init() {
            log('ðŸš€ Starting...', 'info');
            updateDisplay('stateDisplay', 'INITIALIZING', 'warn');
            
            try {
                // Get ESP32 IP (optional - can start without it)
                espIP = document.getElementById('espIP').value.trim();
                if (espIP) {
                    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
                    if (!ipRegex.test(espIP)) {
                        log('âš ï¸ Invalid IP format (optional)', 'warn');
                        espIP = '';
                    }
                }
                
                // Request camera - EXACTLY like reference code
                log('ðŸ“· Requesting camera...', 'info');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                
                if (!stream) {
                    throw new Error('No camera stream received');
                }
                
                video.srcObject = stream;
                log('âœ… Camera stream assigned', 'success');
                
                // Wait for metadata - EXACTLY like reference code
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        log(`âœ… Camera ready: ${canvas.width}x${canvas.height}`, 'success');
                        updateDisplay('stateDisplay', 'LOADING AI...', 'warn');
                        resolve();
                    };
                });
                
                // Load AI model
                log('ðŸ§  Loading AI model...', 'info');
                model = await cocoSsd.load();
                log('âœ… AI loaded', 'success');
                
                // Initialize controllers
                initControllers();
                
                systemRunning = true;
                document.getElementById('startBtn').textContent = 'STOP';
                document.getElementById('startBtn').classList.add('active');
                
                log('âœ… Ready', 'success');
                log('ðŸ’¡ Commands are always calculated - Click "FOLLOW ON" to send to ESP32', 'info');
                updateDisplay('stateDisplay', 'READY', 'success');
                
                // Start detection - use requestAnimationFrame like reference
                detect();
                
            } catch (e) {
                log('âŒ Error: ' + e.message, 'error');
                console.error('Init error:', e);
                updateDisplay('stateDisplay', 'ERROR', 'error');
                
                // Show helpful error messages
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    log('ðŸ’¡ Please allow camera permissions', 'info');
                } else if (e.name === 'NotFoundError') {
                    log('ðŸ’¡ No camera found', 'info');
                } else if (e.name === 'NotReadableError') {
                    log('ðŸ’¡ Camera is being used by another app', 'info');
                }
            }
        }
        
        async function startSystem() {
            if (systemRunning) {
                stopSystem();
                return;
            }
            init();
        }

        function stopSystem() {
            systemRunning = false;
            followActive = false;
            
            // Stop camera stream
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => {
                    track.stop();
                    track.enabled = false;
                });
                video.srcObject = null;
            }
            
            // Send stop command
            sendCommand(0, 0);
            
            // Reset state
            targetPerson = null;
            lostFrames = 0;
            personTracker.reset();
            if (steerPID) steerPID.reset();
            if (speedPID) speedPID.reset();
            if (xFilter) xFilter.reset();
            if (sizeFilter) sizeFilter.reset();
            
            // Update UI
            document.getElementById('startBtn').textContent = 'START';
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('followBtn').textContent = 'FOLLOW OFF';
            document.getElementById('followBtn').classList.remove('active');
            document.getElementById('followBtn').style.borderColor = '#888';
            document.getElementById('followBtn').style.color = '#888';
            
            // Clear canvas
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Reset status displays
            updateDisplay('stateDisplay', 'STOPPED');
            updateDisplay('targetX', '-');
            updateDisplay('targetSize', '-');
            updateDisplay('errorX', '-');
            updateDisplay('errorSize', '-');
            updateDisplay('steerOut', '0');
            updateDisplay('driveOut', '0');
            updateDisplay('confidence', '-');
            updateDisplay('fps', '0');
            
            connectionStatus = 'disconnected';
            consecutiveErrors = 0;
            updateConnectionStatus();
            
            log('System stopped', 'info');
        }

        function toggleFollow() {
            if (!systemRunning) {
                log('âš ï¸ System not running!', 'warn');
                return;
            }
            
            followActive = !followActive;
            const btn = document.getElementById('followBtn');
            
            if (followActive) {
                btn.textContent = 'FOLLOW ON';
                btn.classList.add('active');
                btn.style.borderColor = '#0f0';
                btn.style.color = '#0f0';
                log('âœ… FOLLOW ENABLED - Commands will be sent to ESP32', 'success');
                
                // Check ESP32 IP
                espIP = document.getElementById('espIP').value.trim();
                if (!espIP) {
                    log('âš ï¸ No ESP32 IP - Enter IP to send commands', 'warn');
                    log('ðŸ’¡ Commands are still calculated and displayed', 'info');
                } else {
                    log(`ðŸ“¡ ESP32 IP: ${espIP} - Ready to control bot!`, 'success');
                }
            } else {
                btn.textContent = 'FOLLOW OFF';
                btn.classList.remove('active');
                btn.style.borderColor = '#888';
                btn.style.color = '#888';
                sendCommand(0, 0);
                log('â¸ï¸ FOLLOW DISABLED - Commands displayed only', 'warn');
            }
        }

        // ============ DETECTION LOOP - SIMPLIFIED LIKE REFERENCE CODE ============
        async function detect() {
            if (!systemRunning || !model) {
                requestAnimationFrame(detect);
                return;
            }
            
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            try {
                // Detect people - EXACTLY like reference code
                const predictions = await model.detect(video);
                const people = predictions.filter(p => 
                    p.class === 'person' && p.score >= CONFIG.MIN_CONFIDENCE
                );
                
                // FPS calculation
                frameCount++;
                if (Date.now() - lastFPSTime > 1000) {
                    updateDisplay('fps', frameCount);
                    frameCount = 0;
                    lastFPSTime = Date.now();
                }
                
                // Update tracker
                const bbox = personTracker.update(people);
                
                // Draw all detected people (for awareness) - make them more visible
                people.forEach((person, index) => {
                    const [x, y, w, h] = person.bbox;
                    // Draw bounding box
                    ctx.strokeStyle = 'rgba(255,255,0,0.8)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Draw label with confidence
                    ctx.fillStyle = 'rgba(255,255,0,0.9)';
                    ctx.font = '16px monospace';
                    ctx.fillText(
                        `Person ${index + 1}: ${(person.score * 100).toFixed(0)}%`,
                        x,
                        y > 20 ? y - 5 : y + 20
                    );
                });
                
                if (bbox) {
                    targetPerson = bbox;
                    lostFrames = 0;
                    
                    const [x, y, w, h] = bbox;
                    
                    // Validate bbox values
                    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h) || w <= 0 || h <= 0) {
                        throw new Error('Invalid bounding box values');
                    }
                    
                    // Draw target person - make it very visible
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 5;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Draw filled rectangle with transparency
                    ctx.fillStyle = 'rgba(0,255,0,0.1)';
                    ctx.fillRect(x, y, w, h);
                    
                    // Calculate center
                    const centerX = x + w / 2;
                    const centerY = y + h / 2;
                    
                    // Draw crosshair
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, centerY);
                    ctx.lineTo(centerX + 20, centerY);
                    ctx.moveTo(centerX, centerY - 20);
                    ctx.lineTo(centerX, centerY + 20);
                    ctx.stroke();
                    
                    // Smooth values with Kalman filter
                    const smoothX = xFilter.update(centerX);
                    const personSize = (w * h) / (canvas.width * canvas.height);
                    const smoothSize = sizeFilter.update(personSize);
                    
                    // Update state machine
                    const state = stateMachine.updateState(true, smoothSize);
                    updateDisplay('stateDisplay', state, state === 'FOLLOWING' ? '' : 'warn');
                    
                    // Draw screen center line
                    ctx.strokeStyle = 'rgba(0,255,255,0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw center indicator
                    ctx.fillStyle = 'rgba(0,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw offset line
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, centerY);
                    ctx.lineTo(smoothX, centerY);
                    ctx.stroke();
                    
                    // Calculate distance and offset (like reference code)
                    const fcx = canvas.width / 2;
                    const fcy = canvas.height / 2;
                    const dx = smoothX - fcx;
                    const dy = centerY - fcy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Update display
                    updateDisplay('targetX', smoothX.toFixed(0));
                    updateDisplay('targetSize', (smoothSize * 100).toFixed(1) + '%');
                    updateDisplay('errorX', (dx).toFixed(0) + 'px');
                    updateDisplay('errorSize', (dist).toFixed(0) + 'px');
                    const matchedPerson = people.find(p => 
                        Math.abs(p.bbox[0] - x) < 5 && 
                        Math.abs(p.bbox[1] - y) < 5
                    );
                    updateDisplay('confidence', matchedPerson ? (matchedPerson.score * 100).toFixed(0) + '%' : '-');
                    
                    // ALWAYS calculate commands (like reference code)
                    processPerson(centerX, centerY, dx, dy, dist, state);
                    
                } else {
                    lostFrames++;
                    targetPerson = null;
                    
                    const state = stateMachine.updateState(false, 0);
                    updateDisplay('stateDisplay', state, 'error');
                    
                    // Draw "No person detected" message on canvas
                    ctx.fillStyle = 'rgba(255,0,0,0.7)';
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('NO PERSON DETECTED', canvas.width / 2, canvas.height / 2);
                    ctx.textAlign = 'left';
                    
                    // No person - send stop command
                    sendCommand(0, 0);
                    
                    updateDisplay('targetX', 'LOST');
                    updateDisplay('targetSize', '-');
                    updateDisplay('errorX', '-');
                    updateDisplay('errorSize', '-');
                    updateDisplay('confidence', '-');
                    
                    // Log periodically when no person detected
                    if (frameCount % 60 === 0) {
                        log('No person detected in frame', 'warn');
                    }
                }
                
            } catch (error) {
                console.error('Detection error:', error);
            }
            
            // Continue loop - EXACTLY like reference code
            requestAnimationFrame(detect);
        }

        // ============ PROCESS PERSON - SIMPLIFIED LIKE REFERENCE CODE ============
        function processPerson(cx, cy, dx, dy, dist, state) {
            let drive = 0;
            let steer = 0;
            
            // Simple control like reference code - ALWAYS calculate
            if (followActive || true) { // Always calculate, but only send if followActive
                // Steering: based on horizontal offset (like reference: dx/3)
                steer = Math.round(Math.max(-100, Math.min(100, dx / 3)));
                
                // Drive: based on distance (like reference code)
                if (dist > 150) {
                    // Too far - move forward
                    drive = Math.round(Math.min(100, 50 + (dist - 150) / 5));
                } else if (dist < 100) {
                    // Too close - move backward
                    drive = -30;
                } else {
                    // Good distance - maintain position
                    drive = 0;
                }
                
                // State-based adjustments
                if (state === 'TOO_CLOSE') {
                    drive = Math.min(drive, -20); // Force backward
                } else if (state === 'APPROACHING') {
                    drive = Math.max(drive, 25); // Ensure forward
                }
            }
            
            // Update display ALWAYS
            updateDisplay('steerOut', steer, steer !== 0 ? 'warn' : '');
            updateDisplay('driveOut', drive, drive !== 0 ? 'warn' : '');
            
            // Send command only if followActive
            if (followActive) {
                sendCommand(drive, steer);
            }
        }

        // ============ COMMUNICATION ============
        let connectionStatus = 'disconnected';
        let consecutiveErrors = 0;
        const MAX_CONSECUTIVE_ERRORS = 3;
        
        async function sendCommand(drive, steer) {
            // Always update display with commands (even if not sending to ESP32)
            updateDisplay('steerOut', steer, steer !== 0 ? 'warn' : '');
            updateDisplay('driveOut', drive, drive !== 0 ? 'warn' : '');
            
            // If no ESP32 IP, just log the command (for testing)
            if (!espIP || espIP.trim() === '') {
                if (Math.abs(drive) > 0 || Math.abs(steer) > 0) {
                    log(`ðŸ“¡ CMD: Drive=${drive} Steer=${steer} (No ESP32 IP)`, 'info');
                }
                return;
            }
            
            const now = Date.now();
            if (now - lastCommandTime < CONFIG.COMMAND_RATE) return;
            lastCommandTime = now;
            
            try {
                const url = `http://${espIP}/control?drive=${drive}&steer=${steer}`;
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 2000);
                
                const response = await fetch(url, { 
                    method: 'GET',
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeout);
                
                if (response.ok) {
                    consecutiveErrors = 0;
                    if (connectionStatus !== 'connected') {
                        connectionStatus = 'connected';
                        updateConnectionStatus();
                    }
                    // Log successful commands periodically
                    if (Math.abs(drive) > 0 || Math.abs(steer) > 0) {
                        log(`ðŸ“¡ Sent: Drive=${drive} Steer=${steer}`, 'success');
                    }
                } else {
                    consecutiveErrors++;
                    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS && connectionStatus !== 'error') {
                        connectionStatus = 'error';
                        updateConnectionStatus();
                        log(`ESP32 connection error: HTTP ${response.status}`, 'error');
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    consecutiveErrors++;
                    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                        if (connectionStatus !== 'error') {
                            connectionStatus = 'error';
                            updateConnectionStatus();
                        }
                        // Only log every 10th error to avoid spam
                        if (consecutiveErrors % 10 === 0) {
                            log(`ESP32 connection failed: ${error.message}`, 'error');
                        }
                    }
                }
            }
        }
        
        function updateConnectionStatus() {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
                statusEl.textContent = connectionStatus === 'connected' ? 'CONNECTED' : 
                                      connectionStatus === 'error' ? 'DISCONNECTED' : 'CONNECTING';
                statusEl.className = 'status-value ' + 
                    (connectionStatus === 'connected' ? '' : 
                     connectionStatus === 'error' ? 'error' : 'warn');
            }
        }

        async function emergencyStop() {
            followActive = false;
            
            // Send stop command immediately
            sendCommand(0, 0);
            
            // Also try emergency endpoint
            if (espIP) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 2000);
                    await fetch(`http://${espIP}/emergency`, { 
                        method: 'GET',
                        signal: controller.signal,
                        cache: 'no-cache'
                    });
                    clearTimeout(timeout);
                    log('EMERGENCY STOP executed!', 'error');
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        log('Emergency stop command sent (ESP32 may be offline)', 'warn');
                    }
                }
            }
            
            document.getElementById('followBtn').textContent = 'FOLLOW OFF';
            document.getElementById('followBtn').classList.remove('active');
            document.getElementById('followBtn').style.borderColor = '#888';
            document.getElementById('followBtn').style.color = '#888';
        }

        // ============ UI HELPERS ============
        function updateDisplay(id, value, className = '') {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = 'status-value ' + className;
            }
        }

        function log(message, type = 'info') {
            const telemetry = document.getElementById('telemetry');
            if (!telemetry) return;
            
            const entry = document.createElement('div');
            entry.className = 'log ' + type;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            telemetry.insertBefore(entry, telemetry.firstChild);
            
            // Limit log entries to prevent memory issues
            while (telemetry.children.length > 50) {
                telemetry.removeChild(telemetry.lastChild);
            }
            
            // Also log to console for debugging
            if (type === 'error') {
                console.error(`[PersonFollower] ${message}`);
            } else if (type === 'warn') {
                console.warn(`[PersonFollower] ${message}`);
            } else {
                console.log(`[PersonFollower] ${message}`);
            }
        }

        // ============ DIAGNOSTICS ============
        function checkCameraStatus() {
            const status = {
                videoElement: !!video,
                videoSrcObject: !!(video && video.srcObject),
                videoReadyState: video ? video.readyState : -1,
                videoPaused: video ? video.paused : true,
                videoEnded: video ? video.ended : true,
                videoWidth: video ? video.videoWidth : 0,
                videoHeight: video ? video.videoHeight : 0,
                canvasWidth: canvas ? canvas.width : 0,
                canvasHeight: canvas ? canvas.height : 0,
                modelLoaded: !!model,
                systemRunning: systemRunning,
                videoVisible: video ? (video.offsetWidth > 0 && video.offsetHeight > 0) : false,
                videoDisplay: video ? window.getComputedStyle(video).display : 'none',
                videoVisibility: video ? window.getComputedStyle(video).visibility : 'hidden'
            };
            
            log('=== Camera Diagnostics ===', 'info');
            log(`Video element exists: ${status.videoElement}`, status.videoElement ? 'success' : 'error');
            log(`Video stream active: ${status.videoSrcObject}`, status.videoSrcObject ? 'success' : 'error');
            log(`Video readyState: ${status.videoReadyState} (2=HAVE_CURRENT_DATA, 4=HAVE_ENOUGH_DATA)`, 'info');
            log(`Video paused: ${status.videoPaused}`, status.videoPaused ? 'error' : 'success');
            log(`Video size: ${status.videoWidth}x${status.videoHeight}`, status.videoWidth > 0 ? 'success' : 'error');
            log(`Video visible: ${status.videoVisible} (display: ${status.videoDisplay}, visibility: ${status.videoVisibility})`, status.videoVisible ? 'success' : 'error');
            log(`Canvas size: ${status.canvasWidth}x${status.canvasHeight}`, status.canvasWidth > 0 ? 'success' : 'error');
            log(`AI Model loaded: ${status.modelLoaded}`, status.modelLoaded ? 'success' : 'error');
            log(`System running: ${status.systemRunning}`, status.systemRunning ? 'success' : 'warn');
            log(`Detection processing: ${isProcessing}`, 'info');
            
            // Test video frame capture
            if (video && video.readyState >= 2 && canvas.width > 0) {
                try {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    const hasData = imageData.data.some(val => val !== 0);
                    log(`Video frame capture test: ${hasData ? 'SUCCESS - frames are updating' : 'FAILED - no frame data'}`, hasData ? 'success' : 'error');
                } catch (e) {
                    log(`Video frame capture test failed: ${e.message}`, 'error');
                }
            }
            
            console.log('Full diagnostic status:', status);
            return status;
        }
        
        // ============ INITIALIZATION ============
        // Initialize connection status on load
        window.addEventListener('DOMContentLoaded', () => {
            updateConnectionStatus();
            
            // Load saved ESP32 IP if available (with error handling for tracking prevention)
            try {
                const savedIP = localStorage.getItem('esp32IP');
                if (savedIP) {
                    document.getElementById('espIP').value = savedIP;
                }
                
                // Save IP when changed
                document.getElementById('espIP').addEventListener('change', (e) => {
                    try {
                        localStorage.setItem('esp32IP', e.target.value);
                    } catch (err) {
                        // Ignore localStorage errors (tracking prevention)
                        console.log('LocalStorage not available (tracking prevention enabled)');
                    }
                });
            } catch (err) {
                // LocalStorage blocked - that's okay, just continue without saving
                console.log('LocalStorage not available');
            }
            
            // Add diagnostic button (for debugging)
            const controls = document.getElementById('controls');
            const diagBtn = document.createElement('button');
            diagBtn.textContent = 'DIAGNOSTICS';
            diagBtn.onclick = checkCameraStatus;
            diagBtn.style.marginTop = '5px';
            diagBtn.style.fontSize = '10px';
            controls.appendChild(diagBtn);
        });
        
        // ============ CLEANUP ============
        window.addEventListener('beforeunload', () => {
            if (systemRunning) {
                sendCommand(0, 0);
                if (video && video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
            }
        });
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && systemRunning) {
                // Pause when tab is hidden to save resources
                sendCommand(0, 0);
            }
        });
        
        // Auto-start like reference code
        init();
    </script>
</body>
</html>
