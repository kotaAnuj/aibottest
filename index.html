<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Person Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        #container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border-radius: 12px;
            overflow: hidden;
        }
        video {
            display: block;
            background: black;
            width: 100%;
            max-width: 640px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 900px;
            margin-top: 20px;
        }
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .card h3 {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .card .value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }
        .direction-indicator {
            width: 60px;
            height: 60px;
            margin: 10px auto;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .status-good { color: #4CAF50; }
        .status-warning { color: #FFC107; }
        .status-alert { color: #f44336; }
        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }
        #calibration {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>üéØ Advanced Person Tracker</h1>
    <div id="container">
        <video id="video" width="640" height="480" autoplay playsinline muted></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    
    <div id="dashboard">
        <div class="card">
            <h3>System Status</h3>
            <div class="value" id="status">
                <div class="loading-spinner"></div>
            </div>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidence" style="width: 0%"></div>
            </div>
            <div id="calibration" style="display: none;">
                üìè Calibrating baseline...
            </div>
        </div>

        <div class="card">
            <h3>Horizontal Movement</h3>
            <div class="direction-indicator" id="h-arrow">‚Üî</div>
            <div class="value" id="direction">CENTERED</div>
            <div class="metric">
                <span>Position:</span>
                <span id="h-pos">0px</span>
            </div>
            <div class="metric">
                <span>Offset:</span>
                <span id="h-offset">0px</span>
            </div>
        </div>

        <div class="card">
            <h3>Depth Movement</h3>
            <div class="direction-indicator" id="v-arrow">‚äô</div>
            <div class="value" id="depth">STABLE</div>
            <div class="metric">
                <span>Size Ratio:</span>
                <span id="size-ratio">1.00x</span>
            </div>
            <div class="metric">
                <span>Box Area:</span>
                <span id="box-area">0px¬≤</span>
            </div>
        </div>

        <div class="card">
            <h3>Distance Analysis</h3>
            <div class="value" id="distance">0</div>
            <div class="metric">
                <span>From Center:</span>
                <span id="pythagorean">0.0px</span>
            </div>
            <div class="metric">
                <span>Center Point:</span>
                <span id="center">(0, 0)</span>
            </div>
            <div class="metric">
                <span>Velocity:</span>
                <span id="velocity">0.0 px/s</span>
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const statusEl = document.getElementById('status');
        const confidenceEl = document.getElementById('confidence');
        const directionEl = document.getElementById('direction');
        const depthEl = document.getElementById('depth');
        const distanceEl = document.getElementById('distance');
        const centerEl = document.getElementById('center');
        const hArrowEl = document.getElementById('h-arrow');
        const vArrowEl = document.getElementById('v-arrow');
        const hPosEl = document.getElementById('h-pos');
        const hOffsetEl = document.getElementById('h-offset');
        const sizeRatioEl = document.getElementById('size-ratio');
        const boxAreaEl = document.getElementById('box-area');
        const pythagoreanEl = document.getElementById('pythagorean');
        const velocityEl = document.getElementById('velocity');
        const calibrationEl = document.getElementById('calibration');

        let model;
        let baselineSize = null;
        let calibrationFrames = 0;
        let calibrationSamples = [];
        let lastPosition = null;
        let lastTimestamp = null;
        let isCalibrated = false;

        // Smoothing buffer for stable tracking
        let positionBuffer = [];
        const bufferSize = 5;

        // Initialize camera with better settings
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    }
                });
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve(video);
                    };
                });
            } catch (err) {
                statusEl.innerHTML = '<span class="status-alert">‚ùå Camera Error</span>';
                console.error('Camera error:', err);
                alert('Camera access is required. Please enable camera permissions.');
            }
        }

        // Load TensorFlow model
        async function loadModel() {
            try {
                statusEl.innerHTML = '<div class="loading-spinner"></div>';
                model = await cocoSsd.load({
                    base: 'mobilenet_v2'
                });
                statusEl.innerHTML = '<span class="status-good">‚úÖ Active</span>';
                calibrationEl.style.display = 'block';
            } catch (err) {
                statusEl.innerHTML = '<span class="status-alert">‚ùå Model Failed</span>';
                console.error('Model load error:', err);
            }
        }

        // Smooth position using moving average
        function smoothPosition(x, y) {
            positionBuffer.push({ x, y });
            if (positionBuffer.length > bufferSize) {
                positionBuffer.shift();
            }
            
            const avgX = positionBuffer.reduce((sum, pos) => sum + pos.x, 0) / positionBuffer.length;
            const avgY = positionBuffer.reduce((sum, pos) => sum + pos.y, 0) / positionBuffer.length;
            
            return { x: avgX, y: avgY };
        }

        // Calculate Pythagorean distance
        function calculateDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculate velocity
        function calculateVelocity(currentPos, currentTime) {
            if (!lastPosition || !lastTimestamp) {
                lastPosition = currentPos;
                lastTimestamp = currentTime;
                return 0;
            }

            const distance = calculateDistance(
                lastPosition.x, lastPosition.y,
                currentPos.x, currentPos.y
            );
            const timeDiff = (currentTime - lastTimestamp) / 1000; // Convert to seconds
            const velocity = distance / timeDiff;

            lastPosition = currentPos;
            lastTimestamp = currentTime;

            return velocity;
        }

        // Main detection loop
        async function detectPerson() {
            if (!model) {
                requestAnimationFrame(detectPerson);
                return;
            }

            const predictions = await model.detect(video);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Find the most confident person detection
            const people = predictions.filter(pred => pred.class === 'person');
            const person = people.reduce((best, current) => 
                (!best || current.score > best.score) ? current : best
            , null);

            if (person && person.score > 0.4) {
                const [x, y, width, height] = person.bbox;
                const confidence = Math.round(person.score * 100);
                
                // Update confidence bar
                confidenceEl.style.width = confidence + '%';
                
                // Calculate raw center point
                const rawCenterX = x + width / 2;
                const rawCenterY = y + height / 2;
                
                // Smooth the center point
                const smoothed = smoothPosition(rawCenterX, rawCenterY);
                const centerX = smoothed.x;
                const centerY = smoothed.y;
                
                // Screen center
                const screenCenterX = canvas.width / 2;
                const screenCenterY = canvas.height / 2;

                // Calculate distance using Pythagorean theorem
                const distanceFromCenter = calculateDistance(
                    centerX, centerY, 
                    screenCenterX, screenCenterY
                );

                // Calculate velocity
                const velocity = calculateVelocity(
                    { x: centerX, y: centerY },
                    Date.now()
                );

                // === CALIBRATION PHASE ===
                if (!isCalibrated && calibrationFrames < 30) {
                    calibrationSamples.push(width * height);
                    calibrationFrames++;
                    
                    if (calibrationFrames === 30) {
                        baselineSize = calibrationSamples.reduce((a, b) => a + b) / calibrationSamples.length;
                        isCalibrated = true;
                        calibrationEl.style.display = 'none';
                        calibrationEl.textContent = '‚úì Calibrated';
                    }
                } else if (!baselineSize) {
                    baselineSize = width * height;
                }

                // === DRAWING ===
                // Draw bounding box with gradient
                const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                gradient.addColorStop(0, '#00FF88');
                gradient.addColorStop(1, '#00FFFF');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);

                // Draw corner indicators
                const cornerSize = 15;
                ctx.fillStyle = '#00FF88';
                // Top-left
                ctx.fillRect(x, y, cornerSize, 3);
                ctx.fillRect(x, y, 3, cornerSize);
                // Top-right
                ctx.fillRect(x + width - cornerSize, y, cornerSize, 3);
                ctx.fillRect(x + width - 3, y, 3, cornerSize);
                // Bottom-left
                ctx.fillRect(x, y + height - 3, cornerSize, 3);
                ctx.fillRect(x, y + height - cornerSize, 3, cornerSize);
                // Bottom-right
                ctx.fillRect(x + width - cornerSize, y + height - 3, cornerSize, 3);
                ctx.fillRect(x + width - 3, y + height - cornerSize, 3, cornerSize);

                // Draw center point with pulse effect
                ctx.fillStyle = '#FF3366';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FF3366';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Draw crosshair at center
                ctx.strokeStyle = '#FF3366';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - 15, centerY);
                ctx.lineTo(centerX + 15, centerY);
                ctx.moveTo(centerX, centerY - 15);
                ctx.lineTo(centerX, centerY + 15);
                ctx.stroke();

                // Draw line to screen center
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(screenCenterX, screenCenterY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw screen center
                ctx.fillStyle = '#00CCFF';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00CCFF';
                ctx.beginPath();
                ctx.arc(screenCenterX, screenCenterY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // === DIRECTION ANALYSIS ===
                const horizontalOffset = centerX - screenCenterX;
                const threshold = 60;
                
                let direction = '';
                let arrow = '';
                
                if (horizontalOffset < -threshold) {
                    direction = 'LEFT';
                    arrow = '‚Üê';
                    directionEl.className = 'value status-alert';
                } else if (horizontalOffset > threshold) {
                    direction = 'RIGHT';
                    arrow = '‚Üí';
                    directionEl.className = 'value status-alert';
                } else {
                    direction = 'CENTERED';
                    arrow = '‚Üï';
                    directionEl.className = 'value status-good';
                }

                // === DEPTH ANALYSIS ===
                const boxSize = width * height;
                const sizeRatio = baselineSize ? boxSize / baselineSize : 1;
                
                let depth = '';
                let depthArrow = '';
                
                if (sizeRatio > 1.15) {
                    depth = 'APPROACHING';
                    depthArrow = '‚¨Ü';
                    depthEl.className = 'value status-alert';
                } else if (sizeRatio < 0.85) {
                    depth = 'RECEDING';
                    depthArrow = '‚¨á';
                    depthEl.className = 'value status-warning';
                } else {
                    depth = 'STABLE';
                    depthArrow = '‚äô';
                    depthEl.className = 'value status-good';
                }

                // === UPDATE UI ===
                directionEl.textContent = direction;
                hArrowEl.textContent = arrow;
                depthEl.textContent = depth;
                vArrowEl.textContent = depthArrow;
                distanceEl.textContent = Math.round(distanceFromCenter);
                centerEl.textContent = `(${Math.round(centerX)}, ${Math.round(centerY)})`;
                hPosEl.textContent = `${Math.round(centerX)}px`;
                hOffsetEl.textContent = `${Math.round(horizontalOffset)}px`;
                sizeRatioEl.textContent = `${sizeRatio.toFixed(2)}x`;
                boxAreaEl.textContent = `${Math.round(boxSize)}px¬≤`;
                pythagoreanEl.textContent = `${distanceFromCenter.toFixed(1)}px`;
                velocityEl.textContent = `${velocity.toFixed(1)} px/s`;

                // Draw info label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(x, y - 35, 180, 30);
                ctx.fillStyle = '#00FF88';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`Person ${confidence}%`, x + 8, y - 12);

            } else {
                // No person detected
                confidenceEl.style.width = '0%';
                directionEl.textContent = 'NO DETECTION';
                directionEl.className = 'value status-warning';
                depthEl.textContent = 'NO DETECTION';
                depthEl.className = 'value status-warning';
                distanceEl.textContent = '-';
                hArrowEl.textContent = '‚óã';
                vArrowEl.textContent = '‚óã';
                
                // Reset calibration if person lost
                positionBuffer = [];
                lastPosition = null;
                lastTimestamp = null;
            }

            requestAnimationFrame(detectPerson);
        }

        // Initialize everything
        async function init() {
            await setupCamera();
            await loadModel();
            detectPerson();
        }

        init();
    </script>
</body>
</html>
