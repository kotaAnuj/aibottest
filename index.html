<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Person Follower</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            z-index: 100;
        }
        #controls input { 
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
            margin: 5px 0;
            width: 200px;
        }
        #controls button {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: monospace;
            font-weight: bold;
        }
        #controls button:hover { background: #0f0; color: #000; }
        #controls button.active { background: #f00; color: #fff; border-color: #f00; }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            min-width: 300px;
            z-index: 100;
        }
        .status-row { 
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 14px;
        }
        .status-label { color: #888; }
        .status-value { color: #0f0; font-weight: bold; }
        .status-value.warn { color: #ff0; }
        .status-value.error { color: #f00; }
        #telemetry {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 2px solid #0f0;
            max-height: 150px;
            overflow-y: auto;
            width: 400px;
            z-index: 100;
            font-size: 12px;
        }
        .log { margin: 2px 0; }
        .log.info { color: #0ff; }
        .log.warn { color: #ff0; }
        .log.error { color: #f00; }
        .log.success { color: #0f0; }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <div><input type="text" id="espIP" placeholder="ESP32 IP (192.168.x.x)"></div>
            <div>
                <button id="startBtn" onclick="startSystem()">START</button>
                <button id="followBtn" onclick="toggleFollow()" style="border-color: #888; color: #888">FOLLOW OFF</button>
                <button onclick="emergencyStop()" style="border-color: #f00; color: #f00">STOP</button>
            </div>
            <div style="margin-top: 10px; font-size: 11px;">
                <div>PID Tuning:</div>
                <div>Steer Kp: <input type="number" id="steerKp" value="2.5" step="0.1" style="width: 80px"></div>
                <div>Steer Kd: <input type="number" id="steerKd" value="1.2" step="0.1" style="width: 80px"></div>
                <div>Speed Kp: <input type="number" id="speedKp" value="200" step="10" style="width: 80px"></div>
            </div>
        </div>
        
        <div id="status">
            <div class="status-row"><span class="status-label">State:</span><span class="status-value" id="stateDisplay">INIT</span></div>
            <div class="status-row"><span class="status-label">Target X:</span><span class="status-value" id="targetX">-</span></div>
            <div class="status-row"><span class="status-label">Target Size:</span><span class="status-value" id="targetSize">-</span></div>
            <div class="status-row"><span class="status-label">Error X:</span><span class="status-value" id="errorX">-</span></div>
            <div class="status-row"><span class="status-label">Error Size:</span><span class="status-value" id="errorSize">-</span></div>
            <div class="status-row"><span class="status-label">Steer:</span><span class="status-value" id="steerOut">0</span></div>
            <div class="status-row"><span class="status-label">Drive:</span><span class="status-value" id="driveOut">0</span></div>
            <div class="status-row"><span class="status-label">FPS:</span><span class="status-value" id="fps">0</span></div>
            <div class="status-row"><span class="status-label">Confidence:</span><span class="status-value" id="confidence">-</span></div>
        </div>
        
        <div id="telemetry"></div>
    </div>

    <script>
        // ============ CONFIGURATION ============
        const CONFIG = {
            // Target distance (person size as % of screen)
            TARGET_SIZE: 0.20,           // Ideal person size (20% of screen)
            MIN_SIZE: 0.08,              // Too far
            MAX_SIZE: 0.35,              // Too close
            
            // Dead zones
            CENTER_DEADZONE: 0.08,       // ±8% from center = no steering
            SIZE_DEADZONE: 0.03,         // ±3% from target size = no speed change
            
            // Speed limits
            MAX_DRIVE: 60,               // Max forward speed
            MAX_STEER: 100,              // Max steering angle
            MIN_DRIVE: 25,               // Minimum speed to move
            
            // Control rates
            DETECTION_RATE: 100,         // 10 Hz detection
            COMMAND_RATE: 100,           // 10 Hz commands to ESP32
            
            // Tracking
            LOST_TIMEOUT: 15,            // Frames before declaring person lost
            MIN_CONFIDENCE: 0.5,         // Minimum detection confidence
            
            // Smoothing
            KALMAN_PROCESS_NOISE: 0.01,
            KALMAN_MEASUREMENT_NOISE: 0.5,
        };

        // ============ GLOBAL STATE ============
        let video, canvas, ctx;
        let model = null;
        let systemRunning = false;
        let followActive = false;
        let espIP = '';
        
        // PID Controllers
        let steerPID, speedPID;
        
        // Kalman Filters
        let xFilter, sizeFilter;
        
        // Tracking state
        let targetPerson = null;
        let lostFrames = 0;
        let lastCommandTime = 0;
        let frameCount = 0;
        let lastFPSTime = Date.now();
        
        // Performance
        let detectionTimes = [];

        // ============ PID CONTROLLER CLASS ============
        class PIDController {
            constructor(kp, ki, kd, outputMin, outputMax) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
                this.outputMin = outputMin;
                this.outputMax = outputMax;
                
                this.lastError = 0;
                this.integral = 0;
                this.lastTime = Date.now();
            }
            
            update(error) {
                const now = Date.now();
                const dt = (now - this.lastTime) / 1000; // Convert to seconds
                
                if (dt <= 0) return 0;
                
                // Proportional
                const P = this.kp * error;
                
                // Integral with anti-windup
                this.integral += error * dt;
                const maxIntegral = this.outputMax / (this.ki || 1);
                this.integral = Math.max(-maxIntegral, Math.min(maxIntegral, this.integral));
                const I = this.ki * this.integral;
                
                // Derivative
                const derivative = (error - this.lastError) / dt;
                const D = this.kd * derivative;
                
                // Calculate output
                let output = P + I + D;
                
                // Clamp output
                output = Math.max(this.outputMin, Math.min(this.outputMax, output));
                
                // Update state
                this.lastError = error;
                this.lastTime = now;
                
                return output;
            }
            
            reset() {
                this.lastError = 0;
                this.integral = 0;
                this.lastTime = Date.now();
            }
            
            setGains(kp, ki, kd) {
                this.kp = kp;
                this.ki = ki;
                this.kd = kd;
            }
        }

        // ============ KALMAN FILTER CLASS ============
        class KalmanFilter1D {
            constructor(processNoise, measurementNoise) {
                this.q = processNoise;      // Process noise
                this.r = measurementNoise;  // Measurement noise
                this.x = 0;                 // Estimated value
                this.p = 1;                 // Estimation error covariance
                this.k = 0;                 // Kalman gain
            }
            
            update(measurement) {
                // Prediction
                // x = x (no change in prediction)
                this.p = this.p + this.q;
                
                // Update
                this.k = this.p / (this.p + this.r);
                this.x = this.x + this.k * (measurement - this.x);
                this.p = (1 - this.k) * this.p;
                
                return this.x;
            }
            
            reset(value = 0) {
                this.x = value;
                this.p = 1;
            }
        }

        // ============ PERSON TRACKER CLASS ============
        class PersonTracker {
            constructor() {
                this.trackedBBox = null;
                this.lostCount = 0;
                this.trackingHistory = [];
                this.maxHistory = 5;
            }
            
            calculateIOU(box1, box2) {
                const x1 = Math.max(box1[0], box2[0]);
                const y1 = Math.max(box1[1], box2[1]);
                const x2 = Math.min(box1[0] + box1[2], box2[0] + box2[2]);
                const y2 = Math.min(box1[1] + box1[3], box2[1] + box2[3]);
                
                if (x2 < x1 || y2 < y1) return 0;
                
                const intersection = (x2 - x1) * (y2 - y1);
                const union = box1[2] * box1[3] + box2[2] * box2[3] - intersection;
                
                return intersection / union;
            }
            
            update(people) {
                if (people.length === 0) {
                    this.lostCount++;
                    if (this.lostCount > CONFIG.LOST_TIMEOUT) {
                        this.trackedBBox = null;
                    }
                    return this.trackedBBox;
                }
                
                // First detection - pick largest person
                if (!this.trackedBBox) {
                    const largest = people.reduce((max, p) => 
                        (p.bbox[2] * p.bbox[3] > max.bbox[2] * max.bbox[3]) ? p : max
                    );
                    this.trackedBBox = largest.bbox;
                    this.lostCount = 0;
                    return this.trackedBBox;
                }
                
                // Track using IOU
                let bestMatch = null;
                let bestIOU = 0.2; // Minimum IOU threshold
                
                for (const person of people) {
                    const iou = this.calculateIOU(this.trackedBBox, person.bbox);
                    if (iou > bestIOU) {
                        bestIOU = iou;
                        bestMatch = person;
                    }
                }
                
                if (bestMatch) {
                    this.trackedBBox = bestMatch.bbox;
                    this.lostCount = 0;
                } else {
                    this.lostCount++;
                    if (this.lostCount > CONFIG.LOST_TIMEOUT) {
                        this.trackedBBox = null;
                    }
                }
                
                return this.trackedBBox;
            }
            
            reset() {
                this.trackedBBox = null;
                this.lostCount = 0;
                this.trackingHistory = [];
            }
        }

        // ============ DECISION ENGINE ============
        class FollowingStateMachine {
            constructor() {
                this.state = 'SEARCHING';
                // States: SEARCHING, APPROACHING, FOLLOWING, TOO_CLOSE, LOST
            }
            
            updateState(hasTarget, personSize) {
                if (!hasTarget) {
                    if (this.state !== 'LOST' && this.state !== 'SEARCHING') {
                        this.state = 'LOST';
                    } else if (lostFrames > CONFIG.LOST_TIMEOUT) {
                        this.state = 'SEARCHING';
                    }
                } else {
                    if (personSize < CONFIG.MIN_SIZE) {
                        this.state = 'APPROACHING';
                    } else if (personSize > CONFIG.MAX_SIZE) {
                        this.state = 'TOO_CLOSE';
                    } else {
                        this.state = 'FOLLOWING';
                    }
                }
                
                return this.state;
            }
        }

        // ============ INITIALIZATION ============
        const personTracker = new PersonTracker();
        const stateMachine = new FollowingStateMachine();

        function initControllers() {
            const steerKp = parseFloat(document.getElementById('steerKp').value) || 2.5;
            const steerKd = parseFloat(document.getElementById('steerKd').value) || 1.2;
            const speedKp = parseFloat(document.getElementById('speedKp').value) || 200;
            
            steerPID = new PIDController(steerKp, 0, steerKd, -CONFIG.MAX_STEER, CONFIG.MAX_STEER);
            speedPID = new PIDController(speedKp, 0, 10, -CONFIG.MAX_DRIVE, CONFIG.MAX_DRIVE);
            
            xFilter = new KalmanFilter1D(CONFIG.KALMAN_PROCESS_NOISE, CONFIG.KALMAN_MEASUREMENT_NOISE);
            sizeFilter = new KalmanFilter1D(CONFIG.KALMAN_PROCESS_NOISE, CONFIG.KALMAN_MEASUREMENT_NOISE * 2);
        }

        async function startSystem() {
            if (systemRunning) {
                stopSystem();
                return;
            }
            
            video = document.getElementById('videoElement');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            espIP = document.getElementById('espIP').value.trim();
            
            if (!espIP) {
                log('Enter ESP32 IP address first!', 'error');
                return;
            }
            
            log('Starting camera...', 'info');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });
                
                video.srcObject = stream;
                
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
                
                log('Camera ready. Loading AI model...', 'success');
                
                if (!model) {
                    model = await cocoSsd.load();
                    log('AI model loaded!', 'success');
                }
                
                initControllers();
                
                systemRunning = true;
                document.getElementById('startBtn').textContent = 'STOP';
                document.getElementById('startBtn').classList.add('active');
                
                log('System running! Enable FOLLOW to start tracking', 'success');
                
                detectionLoop();
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }

        function stopSystem() {
            systemRunning = false;
            followActive = false;
            
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            
            sendCommand(0, 0);
            
            document.getElementById('startBtn').textContent = 'START';
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('followBtn').textContent = 'FOLLOW OFF';
            document.getElementById('followBtn').classList.remove('active');
            
            log('System stopped', 'info');
        }

        function toggleFollow() {
            followActive = !followActive;
            const btn = document.getElementById('followBtn');
            
            if (followActive) {
                btn.textContent = 'FOLLOW ON';
                btn.classList.add('active');
                btn.style.borderColor = '#0f0';
                btn.style.color = '#0f0';
                log('Follow mode ENABLED', 'success');
                
                // Reset controllers
                steerPID.reset();
                speedPID.reset();
                personTracker.reset();
            } else {
                btn.textContent = 'FOLLOW OFF';
                btn.classList.remove('active');
                btn.style.borderColor = '#888';
                btn.style.color = '#888';
                sendCommand(0, 0);
                log('Follow mode DISABLED', 'warn');
            }
        }

        // ============ DETECTION LOOP ============
        async function detectionLoop() {
            if (!systemRunning) return;
            
            const startTime = performance.now();
            
            try {
                // Detect people
                const predictions = await model.detect(video);
                const people = predictions.filter(p => 
                    p.class === 'person' && p.score >= CONFIG.MIN_CONFIDENCE
                );
                
                // Update tracker
                const bbox = personTracker.update(people);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw all detected people (for awareness)
                people.forEach(person => {
                    const [x, y, w, h] = person.bbox;
                    ctx.strokeStyle = 'rgba(255,255,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                });
                
                if (bbox) {
                    targetPerson = bbox;
                    lostFrames = 0;
                    
                    const [x, y, w, h] = bbox;
                    
                    // Draw target person
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Calculate center
                    const centerX = x + w / 2;
                    const centerY = y + h / 2;
                    
                    // Draw crosshair
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, centerY);
                    ctx.lineTo(centerX + 20, centerY);
                    ctx.moveTo(centerX, centerY - 20);
                    ctx.lineTo(centerX, centerY + 20);
                    ctx.stroke();
                    
                    // Smooth values with Kalman filter
                    const smoothX = xFilter.update(centerX);
                    const personSize = (w * h) / (canvas.width * canvas.height);
                    const smoothSize = sizeFilter.update(personSize);
                    
                    // Update state machine
                    const state = stateMachine.updateState(true, smoothSize);
                    updateDisplay('stateDisplay', state, state === 'FOLLOWING' ? '' : 'warn');
                    
                    // Draw screen center line
                    ctx.strokeStyle = 'rgba(0,255,255,0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw offset line
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, centerY);
                    ctx.lineTo(smoothX, centerY);
                    ctx.stroke();
                    
                    // Calculate control if following
                    if (followActive) {
                        calculateControl(smoothX, smoothSize, state);
                    } else {
                        sendCommand(0, 0);
                    }
                    
                    // Update display
                    updateDisplay('targetX', smoothX.toFixed(0));
                    updateDisplay('targetSize', (smoothSize * 100).toFixed(1) + '%');
                    updateDisplay('confidence', (people.find(p => p.bbox === bbox)?.score * 100 || 0).toFixed(0) + '%');
                    
                } else {
                    lostFrames++;
                    targetPerson = null;
                    
                    const state = stateMachine.updateState(false, 0);
                    updateDisplay('stateDisplay', state, 'error');
                    
                    if (followActive) {
                        sendCommand(0, 0);
                    }
                    
                    updateDisplay('targetX', 'LOST');
                    updateDisplay('targetSize', '-');
                    updateDisplay('confidence', '-');
                }
                
                // FPS calculation
                frameCount++;
                if (Date.now() - lastFPSTime > 1000) {
                    updateDisplay('fps', frameCount);
                    frameCount = 0;
                    lastFPSTime = Date.now();
                }
                
            } catch (error) {
                log(`Detection error: ${error.message}`, 'error');
            }
            
            const processingTime = performance.now() - startTime;
            detectionTimes.push(processingTime);
            if (detectionTimes.length > 10) detectionTimes.shift();
            
            const avgTime = detectionTimes.reduce((a,b) => a+b, 0) / detectionTimes.length;
            const delay = Math.max(0, CONFIG.DETECTION_RATE - avgTime);
            
            setTimeout(detectionLoop, delay);
        }

        // ============ CONTROL CALCULATION ============
        function calculateControl(smoothX, smoothSize, state) {
            const centerScreen = canvas.width / 2;
            
            // Calculate errors
            const errorX = (smoothX - centerScreen) / canvas.width; // Normalized -0.5 to 0.5
            const errorSize = smoothSize - CONFIG.TARGET_SIZE;
            
            // Apply deadzone to errorX
            let adjustedErrorX = errorX;
            if (Math.abs(errorX) < CONFIG.CENTER_DEADZONE) {
                adjustedErrorX = 0;
            }
            
            // Apply deadzone to errorSize
            let adjustedErrorSize = errorSize;
            if (Math.abs(errorSize) < CONFIG.SIZE_DEADZONE) {
                adjustedErrorSize = 0;
            }
            
            // Update PID gains from UI
            const steerKp = parseFloat(document.getElementById('steerKp').value) || 2.5;
            const steerKd = parseFloat(document.getElementById('steerKd').value) || 1.2;
            const speedKp = parseFloat(document.getElementById('speedKp').value) || 200;
            steerPID.setGains(steerKp, 0, steerKd);
            speedPID.setGains(speedKp, 0, 10);
            
            // Calculate PID outputs
            let steer = steerPID.update(adjustedErrorX);
            let drive = speedPID.update(-adjustedErrorSize); // Negative because larger size = closer = back up
            
            // State-based adjustments
            switch(state) {
                case 'APPROACHING':
                    drive = Math.max(drive, CONFIG.MIN_DRIVE); // Ensure minimum forward speed
                    break;
                case 'TOO_CLOSE':
                    drive = Math.min(drive, 0); // Only allow backwards or stop
                    break;
                case 'FOLLOWING':
                    // Normal operation
                    break;
                case 'SEARCHING':
                case 'LOST':
                    drive = 0;
                    steer = 0;
                    break;
            }
            
            // Apply minimum drive threshold
            if (Math.abs(drive) < CONFIG.MIN_DRIVE && Math.abs(drive) > 0) {
                drive = drive > 0 ? CONFIG.MIN_DRIVE : -CONFIG.MIN_DRIVE;
            }
            
            // Round for cleaner output
            steer = Math.round(steer);
            drive = Math.round(drive);
            
            // Send command
            sendCommand(drive, steer);
            
            // Update display
            updateDisplay('errorX', (errorX * 100).toFixed(1) + '%');
            updateDisplay('errorSize', (errorSize * 100).toFixed(1) + '%');
            updateDisplay('steerOut', steer, steer !== 0 ? 'warn' : '');
            updateDisplay('driveOut', drive, drive !== 0 ? 'warn' : '');
        }

        // ============ COMMUNICATION ============
        async function sendCommand(drive, steer) {
            const now = Date.now();
            if (now - lastCommandTime < CONFIG.COMMAND_RATE) return;
            lastCommandTime = now;
            
            try {
                const url = `http://${espIP}/control?drive=${drive}&steer=${steer}`;
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 1000);
                
                const response = await fetch(url, { 
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeout);
                
                if (response.ok) {
                    // log(`CMD: D=${drive} S=${steer}`, 'success');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    log(`Connection error: ${error.message}`, 'error');
                }
            }
        }

        async function emergencyStop() {
            followActive = false;
            sendCommand(0, 0);
            
            try {
                await fetch(`http://${espIP}/emergency`, { method: 'GET' });
                log('EMERGENCY STOP!', 'error');
            } catch (error) {
                log('Emergency stop command failed', 'error');
            }
            
            document.getElementById('followBtn').textContent = 'FOLLOW OFF';
            document.getElementById('followBtn').classList.remove('active');
        }

        // ============ UI HELPERS ============
        function updateDisplay(id, value, className = '') {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = 'status-value ' + className;
            }
        }

        function log(message, type = 'info') {
            const telemetry = document.getElementById('telemetry');
            const entry = document.createElement('div');
            entry.className = 'log ' + type;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            telemetry.insertBefore(entry, telemetry.firstChild);
            
            while (telemetry.children.length > 50) {
                telemetry.removeChild(telemetry.lastChild);
            }
        }

        // ============ CLEANUP ============
        window.addEventListener('beforeunload', () => {
            if (systemRunning) {
                sendCommand(0, 0);
            }
        });
    </script>
</body>
</html>
