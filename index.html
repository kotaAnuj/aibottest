<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC Car Person Follower</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
        }
        h1 {
            margin: 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }
        .controls-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .btn-danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; }
        button:hover { transform: scale(1.05); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        #container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            max-width: 100%;
        }
        video {
            display: block;
            background: black;
            width: 100%;
            max-width: 640px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 1200px;
        }
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .card h3 {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .card .value { font-size: 24px; font-weight: bold; margin-top: 5px; }
        .command-display {
            font-size: 32px;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin: 10px 0;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .status-good { color: #4CAF50; }
        .status-warning { color: #FFC107; }
        .status-alert { color: #f44336; }
        .metric { display: flex; justify-content: space-between; margin: 8px 0; font-size: 14px; }
        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }
        .direction-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left stop right"
                ". down .";
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }
        .direction-pad button { width: 60px; height: 60px; font-size: 24px; }
        .up { grid-area: up; } .down { grid-area: down; } .left { grid-area: left; }
        .right { grid-area: right; } .stop { grid-area: stop; background: #f44336; }
        #commandLog {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-entry {
            padding: 5px;
            margin: 3px 0;
            border-left: 3px solid #4CAF50;
            padding-left: 10px;
        }
        .mode-indicator {
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin: 10px;
        }
        .mode-auto { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .mode-manual { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
    </style>
</head>
<body>
    <h1>üöó RC Car Person Follower System</h1>
    
    <div class="controls-bar">
        <button class="btn-primary" id="switchCam">üì∑ Switch Camera</button>
        <button class="btn-success" id="toggleMode">ü§ñ Enable Auto-Follow</button>
        <button class="btn-danger" id="emergencyStop">‚ö†Ô∏è EMERGENCY STOP</button>
    </div>

    <div class="mode-indicator mode-manual" id="modeIndicator">
        üîß MANUAL MODE
    </div>
    
    <div id="container">
        <video id="video" width="640" height="480" autoplay playsinline muted></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    
    <div id="dashboard">
        <div class="card">
            <h3>System Status</h3>
            <div class="value" id="status">Initializing...</div>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidence" style="width: 0%"></div>
            </div>
            <div class="metric"><span>Camera:</span><span id="cameraMode">Front</span></div>
            <div class="metric"><span>FPS:</span><span id="fps">0</span></div>
            <div class="metric"><span>Battery:</span><span id="batteryLevel">100%</span></div>
            <div class="metric"><span>Follow Time:</span><span id="followTime">0s</span></div>
        </div>

        <div class="card">
            <h3>Car Command</h3>
            <div class="command-display" id="carCommand">STOP</div>
            <div class="metric"><span>Speed:</span><span id="speed">0%</span></div>
            <div class="metric"><span>Last Update:</span><span id="lastUpdate">-</span></div>
            <div class="metric"><span>Turn:</span><span id="turnValue">0¬∞</span></div>
        </div>

        <div class="card">
            <h3>Person Tracking</h3>
            <div class="metric"><span>Horizontal:</span><span id="horizontal" class="status-warning">SEARCHING</span></div>
            <div class="metric"><span>Distance:</span><span id="distance">0px</span></div>
            <div class="metric"><span>Depth:</span><span id="depth" class="status-alert">UNKNOWN</span></div>
            <div class="metric"><span>Position:</span><span id="position">(0, 0)</span></div>
        </div>

        <div class="card">
            <h3>Manual Override</h3>
            <div class="direction-pad">
                <button class="up btn-primary" onclick="manualControl('FORWARD')">‚Üë</button>
                <button class="left btn-primary" onclick="manualControl('LEFT')">‚Üê</button>
                <button class="stop btn-danger" onclick="manualControl('STOP')">‚¨õ</button>
                <button class="right btn-primary" onclick="manualControl('RIGHT')">‚Üí</button>
                <button class="down btn-primary" onclick="manualControl('BACKWARD')">‚Üì</button>
            </div>
        </div>

        <div class="card">
            <h3>Command Log</h3>
            <div id="commandLog"></div>
        </div>

        <div class="card">
            <h3>Movement Analysis</h3>
            <div class="metric"><span>X Offset:</span><span id="xOffset">0px</span></div>
            <div class="metric"><span>Size Ratio:</span><span id="sizeRatio">1.00x</span></div>
            <div class="metric"><span>Confidence:</span><span id="confPercent">0%</span></div>
            <div class="metric"><span>Target Lock:</span><span id="targetLock" class="status-alert">SEARCHING</span></div>
            <div class="metric"><span>Obstacle:</span><span id="obstacleStatus" class="status-good">CLEAR</span></div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const ui = {
            status: document.getElementById('status'),
            cameraMode: document.getElementById('cameraMode'),
            modeIndicator: document.getElementById('modeIndicator'),
            toggleMode: document.getElementById('toggleMode'),
            carCommand: document.getElementById('carCommand'),
            speed: document.getElementById('speed'),
            turn: document.getElementById('turnValue'),
            lastUpdate: document.getElementById('lastUpdate'),
            horizontal: document.getElementById('horizontal'),
            distance: document.getElementById('distance'),
            depth: document.getElementById('depth'),
            position: document.getElementById('position'),
            log: document.getElementById('commandLog'),
            confidenceFill: document.getElementById('confidence'),
            confPercent: document.getElementById('confPercent'),
            fps: document.getElementById('fps'),
            xOffset: document.getElementById('xOffset'),
            sizeRatio: document.getElementById('sizeRatio'),
            targetLock: document.getElementById('targetLock'),
            obstacle: document.getElementById('obstacleStatus'),
            battery: document.getElementById('batteryLevel'),
            followTime: document.getElementById('followTime')
        };

        const CONFIG = {
            COMMAND_RATE: 120,
            CONFIDENCE_MIN: 0.58,
            EMA_ALPHA: 0.35,
            DEAD_ZONE: 40,
            MAX_STEER: 90,
            MIN_STEER: 15,
            SPEED_PROFILE: { MAX: 85, MIN: 25, BACK_MAX: -70 },
            DISTANCE_ZONES: {
                DANGER: 1.45,
                COMFORT_MAX: 1.15,
                COMFORT_MIN: 0.85,
                WARNING: 0.65,
                LOST: 0.45
            },
            COMMAND_BUFFER: 4,
            OBSTACLE: { CORRIDOR: 0.35, AREA: 12000, CONFIDENCE: 0.6 },
            TARGET_LOSS_TIMEOUT: 1200,
            MAX_FOLLOW_TIME_MS: 30 * 60 * 1000,
            BATTERY_LOW_THRESHOLD: 0.25,
            BATTERY_DRAIN_PER_COMMAND: 0.0004
        };

        const state = {
            model: null,
            currentCamera: 'user',
            autoFollow: false,
            baselineSize: null,
            lastBox: null,
            lastSeen: 0,
            frameCount: 0,
            lastFpsUpdate: Date.now(),
            commandBuffer: [],
            lastCommandTs: 0,
            obstacleDetected: false,
            followStart: null,
            batteryLevel: 1,
            lastDrive: 0,
            lastSteer: 0,
            searchPhase: 0
        };

        const steerPID = {
            kp: 0.45,
            ki: 0.015,
            kd: 0.12,
            integral: 0,
            prevError: 0,
            prevTime: performance.now(),
            update(error) {
                const now = performance.now();
                const dt = Math.max((now - this.prevTime) / 1000, 0.001);
                this.prevTime = now;
                this.integral += error * dt;
                this.integral = Math.max(-300, Math.min(300, this.integral));
                const derivative = (error - this.prevError) / dt;
                this.prevError = error;
                let output = (this.kp * error) + (this.ki * this.integral) + (this.kd * derivative);
                output = Math.max(-CONFIG.MAX_STEER, Math.min(CONFIG.MAX_STEER, output));
                if (Math.abs(output) < CONFIG.MIN_STEER && Math.abs(error) > CONFIG.DEAD_ZONE) {
                    output = Math.sign(output || error) * CONFIG.MIN_STEER;
                }
                if (Math.abs(error) <= CONFIG.DEAD_ZONE) output = 0;
                return output;
            },
            reset() {
                this.integral = 0;
                this.prevError = 0;
                this.prevTime = performance.now();
            }
        };

        document.getElementById('switchCam').addEventListener('click', async () => {
            state.currentCamera = state.currentCamera === 'user' ? 'environment' : 'user';
            await setupCamera(state.currentCamera);
            ui.cameraMode.textContent = state.currentCamera === 'user' ? 'Front' : 'Back';
            state.baselineSize = null;
            state.lastBox = null;
            logCommand(`Camera switched to ${ui.cameraMode.textContent.toUpperCase()}`);
        });

        document.getElementById('toggleMode').addEventListener('click', () => setAutoFollow(!state.autoFollow));
        document.getElementById('emergencyStop').addEventListener('click', emergencyStop);

        function setAutoFollow(enabled) {
            state.autoFollow = enabled;
            if (enabled) {
                ui.toggleMode.textContent = 'üîß Disable Auto-Follow';
                ui.toggleMode.className = 'btn-danger';
                ui.modeIndicator.textContent = 'ü§ñ AUTO-FOLLOW MODE';
                ui.modeIndicator.className = 'mode-indicator mode-auto';
                state.followStart = Date.now();
                state.commandBuffer = [];
                state.lastDrive = 0;
                state.lastSteer = 0;
                logCommand('Auto-follow enabled');
            } else {
                ui.toggleMode.textContent = 'ü§ñ Enable Auto-Follow';
                ui.toggleMode.className = 'btn-success';
                ui.modeIndicator.textContent = 'üîß MANUAL MODE';
                ui.modeIndicator.className = 'mode-indicator mode-manual';
                steerPID.reset();
                sendManualCommand('STOP');
                logCommand('Manual control engaged');
            }
        }

        function emergencyStop() {
            state.autoFollow = false;
            steerPID.reset();
            sendManualCommand('EMERGENCY STOP', true);
            ui.toggleMode.textContent = 'ü§ñ Enable Auto-Follow';
            ui.toggleMode.className = 'btn-success';
            ui.modeIndicator.textContent = 'üîß MANUAL MODE';
            ui.modeIndicator.className = 'mode-indicator mode-manual';
            logCommand('‚ö†Ô∏è EMERGENCY STOP ACTIVATED', true);
        }

        function manualControl(command) {
            if (!state.autoFollow) {
                sendManualCommand(command);
            }
        }

        function sendManualCommand(label, isEmergency = false) {
            ui.carCommand.textContent = label;
            ui.speed.textContent = /FORWARD|BACKWARD/.test(label) ? '70%' : '0%';
            ui.turn.textContent = /LEFT|RIGHT/.test(label) ? '30¬∞' : '0¬∞';
            ui.lastUpdate.textContent = new Date().toLocaleTimeString();
            logCommand(`MANUAL: ${label}`, isEmergency);
        }

        function logCommand(message, isEmergency = false) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.style.borderLeftColor = isEmergency ? '#f44336' : '#4CAF50';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            ui.log.insertBefore(entry, ui.log.firstChild);
            while (ui.log.childElementCount > 80) {
                ui.log.removeChild(ui.log.lastChild);
            }
        }

        async function setupCamera(facingMode = 'user') {
            try {
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode,
                        frameRate: { ideal: 30 }
                    }
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve(video);
                    };
                });
            } catch (error) {
                console.error('Camera error:', error);
                alert('Camera access failed. Check permissions.');
            }
        }

        async function loadModel() {
            try {
                ui.status.textContent = 'Loading AI...';
                state.model = await cocoSsd.load({ base: 'mobilenet_v2' });
                ui.status.innerHTML = '<span class="status-good">‚úÖ Ready</span>';
                logCommand('AI model loaded (COCO-SSD Mobilenet V2)');
            } catch (error) {
                ui.status.innerHTML = '<span class="status-alert">‚ùå Failed</span>';
                console.error('Model error:', error);
            }
        }

        function smoothValue(prev, value) {
            if (prev == null) return value;
            return (CONFIG.EMA_ALPHA * value) + ((1 - CONFIG.EMA_ALPHA) * prev);
        }

        function maintainTargetLock(people) {
            if (!people.length) {
                if (Date.now() - state.lastSeen > CONFIG.TARGET_LOSS_TIMEOUT) {
                    state.lastBox = null;
                }
                return null;
            }
            let target = null;
            if (state.lastBox) {
                let minDist = Infinity;
                people.forEach(p => {
                    const [x, y, w, h] = p.bbox;
                    const cx = x + w / 2;
                    const cy = y + h / 2;
                    const prevCx = state.lastBox.x + state.lastBox.w / 2;
                    const prevCy = state.lastBox.y + state.lastBox.h / 2;
                    const dist = Math.hypot(cx - prevCx, cy - prevCy);
                    if (dist < minDist) {
                        minDist = dist;
                        target = p;
                    }
                });
            }
            if (!target) {
                target = people.reduce((best, current) =>
                    (!best || current.score > best.score) ? current : best, null);
            }
            if (target) {
                const [x, y, w, h] = target.bbox;
                state.lastBox = { x, y, w, h };
                state.lastSeen = Date.now();
            }
            return target;
        }

        function detectObstacle(predictions, target) {
            const corridorWidth = canvas.width * CONFIG.OBSTACLE.CORRIDOR;
            const leftBoundary = (canvas.width / 2) - corridorWidth / 2;
            const rightBoundary = (canvas.width / 2) + corridorWidth / 2;
            const floorLine = canvas.height * 0.65;
            return predictions.some(pred => {
                if (pred === target || pred.score < CONFIG.OBSTACLE.CONFIDENCE) return false;
                const [x, y, w, h] = pred.bbox;
                const cx = x + w / 2;
                const bottom = y + h;
                const area = w * h;
                return cx >= leftBoundary && cx <= rightBoundary && bottom >= floorLine && area > CONFIG.OBSTACLE.AREA;
            });
        }

        function classifyDepth(sizeRatio) {
            if (sizeRatio >= CONFIG.DISTANCE_ZONES.DANGER) return 'danger';
            if (sizeRatio >= CONFIG.DISTANCE_ZONES.COMFORT_MAX) return 'close';
            if (sizeRatio >= CONFIG.DISTANCE_ZONES.COMFORT_MIN) return 'comfort';
            if (sizeRatio >= CONFIG.DISTANCE_ZONES.WARNING) return 'far';
            if (sizeRatio >= CONFIG.DISTANCE_ZONES.LOST) return 'search';
            return 'lost';
        }

        function computeDriveCommand(zone, sizeRatio) {
            switch (zone) {
                case 'danger':
                    return CONFIG.SPEED_PROFILE.BACK_MAX;
                case 'close':
                    return Math.max(CONFIG.SPEED_PROFILE.BACK_MAX, -120 * (sizeRatio - 1));
                case 'comfort':
                    return 0;
                case 'far':
                    return Math.min(CONFIG.SPEED_PROFILE.MAX, 160 * (1 - sizeRatio));
                case 'search':
                    return CONFIG.SPEED_PROFILE.MIN;
                case 'lost':
                default:
                    return 0;
            }
        }

        function applyCommandFilter(drive, steer) {
            state.commandBuffer.push({ drive, steer });
            if (state.commandBuffer.length > CONFIG.COMMAND_BUFFER) {
                state.commandBuffer.shift();
            }
            const avg = state.commandBuffer.reduce((acc, val) => {
                acc.drive += val.drive;
                acc.steer += val.steer;
                return acc;
            }, { drive: 0, steer: 0 });
            const len = state.commandBuffer.length;
            return {
                drive: avg.drive / len,
                steer: avg.steer / len
            };
        }

        function issueAutoCommand(drive, steer, meta) {
            const now = Date.now();
            if (now - state.lastCommandTs < CONFIG.COMMAND_RATE) return;
            state.lastCommandTs = now;

            if (state.obstacleDetected && drive > 0) {
                drive = 0;
                meta.reason = 'Obstacle';
            }
            const filtered = applyCommandFilter(drive, steer);
            state.lastDrive = filtered.drive;
            state.lastSteer = filtered.steer;
            state.batteryLevel = Math.max(CONFIG.BATTERY_LOW_THRESHOLD,
                state.batteryLevel - CONFIG.BATTERY_DRAIN_PER_COMMAND);
            sendAutoCommand(filtered.drive, filtered.steer, meta);
        }

        function sendAutoCommand(drive, steer, meta = {}) {
            const driveDir = drive > 5 ? 'FORWARD' : drive < -5 ? 'BACKWARD' : 'STOP';
            const turnDir = steer > 5 ? 'RIGHT' : steer < -5 ? 'LEFT' : 'STRAIGHT';
            const drivePct = Math.round(Math.min(100, Math.abs(drive)));
            const steerDeg = Math.round((Math.abs(steer) / CONFIG.MAX_STEER) * 90);
            ui.carCommand.textContent = `${driveDir} | TURN ${turnDir}`;
            ui.speed.textContent = drivePct + '%';
            ui.turn.textContent = steerDeg + '¬∞';
            ui.lastUpdate.textContent = new Date().toLocaleTimeString();
            logCommand(`AUTO: D=${driveDir}(${drivePct}%) S=${turnDir}(${steerDeg}¬∞) ${meta.reason || ''}`.trim());
            // TODO: replace with actual API/WebSocket call to the vehicle
            console.log('AUTO CMD', { drive, steer, meta });
        }

        function performSearchPattern() {
            const elapsed = (Date.now() - state.lastSeen) / 1000;
            const steer = Math.sin(elapsed * 1.2) * 70;
            const drive = elapsed % 4 < 2 ? CONFIG.SPEED_PROFILE.MIN : 0;
            issueAutoCommand(drive, steer, { reason: 'Search pattern' });
        }

        function updateDashboard(data) {
            ui.confidenceFill.style.width = `${data.confidence}%`;
            ui.confPercent.textContent = `${data.confidence}%`;
            ui.fps.textContent = data.fps;
            ui.xOffset.textContent = `${Math.round(data.offset)}px`;
            ui.sizeRatio.textContent = `${data.sizeRatio.toFixed(2)}x`;
            ui.position.textContent = `(${Math.round(data.position.x)}, ${Math.round(data.position.y)})`;
            ui.distance.textContent = `${Math.round(data.distance)}px`;
            ui.horizontal.textContent = data.horizontalLabel;
            ui.horizontal.className = data.horizontalClass;
            ui.depth.textContent = data.depthLabel;
            ui.depth.className = data.depthClass;
            ui.targetLock.textContent = data.lockStatus;
            ui.targetLock.className = data.lockClass;
            ui.obstacle.textContent = state.obstacleDetected ? 'BLOCKED' : 'CLEAR';
            ui.obstacle.className = state.obstacleDetected ? 'status-alert' : 'status-good';
            ui.battery.textContent = `${Math.round(state.batteryLevel * 100)}%`;
            if (state.followStart) {
                const elapsed = Date.now() - state.followStart;
                ui.followTime.textContent = `${Math.floor(elapsed / 1000)}s`;
                if (elapsed > CONFIG.MAX_FOLLOW_TIME_MS) {
                    logCommand('‚ö†Ô∏è Follow session limit reached', true);
                    setAutoFollow(false);
                }
            } else {
                ui.followTime.textContent = '0s';
            }
        }

        function updateFPS() {
            state.frameCount++;
            const now = Date.now();
            if (now - state.lastFpsUpdate >= 1000) {
                ui.fps.textContent = state.frameCount.toString();
                state.frameCount = 0;
                state.lastFpsUpdate = now;
            }
        }

        function drawOverlay(person) {
            const [x, y, width, height] = person.bbox;
            ctx.strokeStyle = '#00FF88';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, width, height);
            ctx.fillStyle = '#FF3366';
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(canvas.width / 2, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(x, y - 30, 150, 24);
            ctx.fillStyle = '#00FF88';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`Person ${Math.round(person.score * 100)}%`, x + 6, y - 12);
        }

        async function detectLoop() {
            if (!state.model) {
                requestAnimationFrame(detectLoop);
                return;
            }
            updateFPS();
            const predictions = await state.model.detect(video);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const people = predictions.filter(p => p.class === 'person' && p.score >= CONFIG.CONFIDENCE_MIN);
            const target = maintainTargetLock(people);

            if (target) {
                drawOverlay(target);
                const [x, y, width, height] = target.bbox;
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const smoothedX = smoothValue(state.lastSmoothedX, centerX);
                const smoothedY = smoothValue(state.lastSmoothedY, centerY);
                state.lastSmoothedX = smoothedX;
                state.lastSmoothedY = smoothedY;
                const offset = smoothedX - canvas.width / 2;
                const distance = Math.hypot(smoothedX - canvas.width / 2, smoothedY - canvas.height / 2);
                const area = width * height;
                state.baselineSize = state.baselineSize ? smoothValue(state.baselineSize, area) : area;
                const sizeRatio = state.baselineSize ? area / state.baselineSize : 1;
                const zone = classifyDepth(sizeRatio);
                const steer = steerPID.update(offset);
                let drive = computeDriveCommand(zone, sizeRatio);
                state.obstacleDetected = detectObstacle(predictions, target);
                const horizontalLabel = Math.abs(offset) < CONFIG.DEAD_ZONE ? 'CENTERED' :
                    offset < 0 ? 'LEFT' : 'RIGHT';
                const horizontalClass = Math.abs(offset) < CONFIG.DEAD_ZONE ? 'status-good' : 'status-warning';
                const depthMap = {
                    danger: { label: 'TOO CLOSE', cls: 'status-alert' },
                    close: { label: 'CLOSE', cls: 'status-warning' },
                    comfort: { label: 'OPTIMAL', cls: 'status-good' },
                    far: { label: 'FAR', cls: 'status-warning' },
                    search: { label: 'RECOVERING', cls: 'status-warning' },
                    lost: { label: 'LOST', cls: 'status-alert' }
                };
                updateDashboard({
                    confidence: Math.round(target.score * 100),
                    fps: ui.fps.textContent,
                    offset,
                    sizeRatio,
                    position: { x: smoothedX, y: smoothedY },
                    distance,
                    horizontalLabel,
                    horizontalClass,
                    depthLabel: depthMap[zone].label,
                    depthClass: depthMap[zone].cls,
                    lockStatus: 'üîí LOCKED',
                    lockClass: 'status-good'
                });

                if (state.autoFollow) {
                    if (zone === 'lost') {
                        performSearchPattern();
                    } else {
                        const steerPenalty = 1 - Math.min(1, Math.abs(steer) / CONFIG.MAX_STEER);
                        if (drive > 0) drive *= steerPenalty;
                        issueAutoCommand(drive, steer, { reason: `Zone:${zone}` });
                    }
                }
            } else {
                ui.targetLock.textContent = 'üîç SEARCHING';
                ui.targetLock.className = 'status-warning';
                ui.confidenceFill.style.width = '0%';
                ui.confPercent.textContent = '0%';
                state.obstacleDetected = false;
                if (state.autoFollow) {
                    performSearchPattern();
                }
            }
            requestAnimationFrame(detectLoop);
        }

        async function init() {
            await setupCamera(state.currentCamera);
            await loadModel();
            detectLoop();
            logCommand('System initialized');
        }

        init();
    </script>
</body>
</html>

